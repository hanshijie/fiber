-- UTF-8 without BOM
local type = type
local string = string
local error = error
local pairs = pairs
local table = table
local concat = table.concat
local ipairs = ipairs
local print = print
local open = io.open

namespace = "fiber"
local namespace = namespace

local template_hint = "// This file is generated by genbeans tool. Do NOT edit it! @formatter:off\n"
local template_bean = [=[
package fiber.bean;

<%d.importd%>

public final class $(bean.name) implements Bean<$(bean.name)>
{
	public static final int TYPE = $(bean.type);
	public static final $(bean.name) STUB = new $(bean.name)();

	<%bprivate $(var.fulltype) $(var.name);\n#1b%>

	public $(bean.name)()
	{
		<%bthis.$(var.name) = $(var.default);\n#2b%>
	}

	public $(bean.name) (<%b$(var.fulltype) $(var.name)#2#, b%>)
	{
		<%bthis.$(var.name) = $(var.name);\n#2b%>
	}

<%b
	public $(var.type) get$(var.name)()	{
		return $(var.name);
	}\nb%>

	@Override
	public int getType() {
		return $(bean.type);
	}

	@Override
	public int getMaxSize() {
		return $(bean.maxsize);
	}

	@Override
	public $(bean.name) create() {
		return new $(bean.name)();
	}

	@Override
	public OctetsStream marshal(OctetsStream os) {
		<%b$(var.marshal);\n#2b%>
		return os;
	}

	@Override
	public OctetsStream unmarshal(OctetsStream s) throws MarshalException {
		<%b$(var.unmarshal);\n#2b%>
		return os;
	}

	@Override
	public $(bean.name) clone() {
		final $(bean.type) _c = new $(bean.type);
		<%b$(var.clone);\n#2b%>
		return _c;
	}

	@Override
	public int hashCode() {
		int h = $(bean.type) * 0x9e3779b1;
		<%bh = h * 31 + 1 + $(var.hashcode);\n#2b%>
		return h;
	}

	@Override
	public boolean equals(Object o)	{
		if(o == this) return true;
		if(!(o instanceof $(bean.name))) return false;
		$(bean.name) _o = ($(bean.name))o;
		<%bif(!$(bean.equals)) return false;\n#2b%>
		return o == _o;
	}

	@Override
	public int compareTo($(bean.name) b) {
		if(b == this) return 0;
		if(b == null) return 1;
		int c;
		<%bc = $(var.compareto); if(c != 0) return c;\n#2b%>
		return 0;
	}

	@Override
	public String toString() {
		StringBuilder s = new StringBuilder("{");
		<%bs.append("$(var.name)" = ); s.append($(var.tostring)); s.append(",");\n#2b$>
		return s.append('}').toString();
	}
}
]=]

local template_rpcbean = template_hint .. [=[
package fiber.bean;

import jane.io.RpcBean;

public final class $(bean.name) extends RpcBean<$(bean.arg), $(bean.res)>
{
	private static final long serialVersionUID = $(bean.uid);
	public  static final $(bean.name) STUB = new $(bean.name)();
	public $(bean.name)() {}
	public $(bean.name)($(bean.arg) a) { arg = a; }
	@Override public int type() { return $(bean.type); }
	@Override public $(bean.name) stub() { return STUB; }
	@Override public $(bean.name) create() { return new $(bean.name)(); }
	@Override public $(bean.arg) createArg() { return new $(bean.arg)(); }
	@Override public $(bean.res) createRes() { return new $(bean.res)(); }
}
]=]

local template_allbeans = template_hint .. [=[
package ]=] .. namespace .. [=[.bean;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import jane.io.Bean;#<#
import jane.io.BeanHandler;
import jane.io.IntMap;#>#

/** 全部beans的注册(自动生成的静态类) */
public final class AllBeans
{
	private AllBeans() {}

	/** 获取全部的bean实例 */
	public static Collection<Bean<?>> getAllBeans()
	{
		List<Bean<?>> r = new ArrayList<]=] .. (jdk7 and "" or "Bean<?>") .. [=[>(#(bean.count));
#(#		r.add(#(bean.name).STUB);
#)#		return r;
	}
#[#
	public static IntMap<BeanHandler<?>> get#(hdl.name)Handlers()
	{
		IntMap<BeanHandler<?>> r = new IntMap<]=] .. (jdk7 and "" or "BeanHandler<?>") .. [=[>(#(hdl.count) * 4);
#(#		r.put(#(bean.type), new #(hdl.path).#(bean.name)Handler());
#)#		return r;
	}
#]#}
]=]

local template_bean_handler = [=[
package #(hdl.path);

import org.apache.mina.core.session.IoSession;
import jane.io.BeanHandler;
import jane.io.Log;
import jane.io.NetManager;
import ]=] .. namespace .. [=[.bean.#(bean.name);

public class #(bean.name)Handler extends BeanHandler<#(bean.name)>
{
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/

	@Override
	public void onProcess(final NetManager manager, final IoSession session, final #(bean.name) arg)
	{
		Log.log.debug("{}.onProcess: arg={}", getClass().getName(), arg);
	}
}
]=]

local template_rpc_handler = [=[
package #(hdl.path);

import org.apache.mina.core.session.IoSession;
import jane.io.Log;
import jane.io.NetManager;
import jane.io.RpcHandler;
import ]=] .. namespace .. [=[.bean.#(bean_arg.name);#<#
import ]=] .. namespace .. [=[.bean.#(bean_res.name);#>#

public class #(bean.name)Handler extends RpcHandler<#(bean_arg.name), #(bean_res.name)>
{
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/
	/*\
#(#	|*| #(var.type) #(var.name)#(var.value);#(var.comment)
#)#	\*/

	@Override
	public boolean onServer(NetManager manager, IoSession session, #(bean_arg.name) arg, #(bean_res.name) res)
	{
		Log.log.debug("{}: onServer: {}", getClass().getName(), arg);
		return true;
	}

	@Override
	public void onClient(NetManager manager, IoSession session, #(bean_arg.name) arg, #(bean_res.name) res)
	{
		Log.log.debug("{}: onClient: arg={},res={}", getClass().getName(), arg, res);
	}

	@Override
	public void onTimeout(NetManager manager, IoSession session, #(bean_arg.name) arg)
	{
		Log.log.debug("{}: onTimeout: {}", getClass().getName(), arg);
	}
}
]=]

local typedef = {}
local function merge(ta, tb)
	local r = {}
	for k, v in pairs(ta) do r[k] = v end
	for k, v in pairs(tb) do r[k] = v end
	return r
end
local function typename(var, t)
	local def = typedef[t]
	if not def then return t end
	if type(def) == "function" then
		local t = { id = 0, import = {} } def(t, 0) def = t
		for k in pairs(t.import) do var.import[k] = true end
	end
	if type(def) == "table" then return type(def.type) == "string" and def.type or def.type(var) end
	error("ERROR: unknown typename(" .. var .. ", " .. t .. ")")
end
local function subtypename(var, t)
	local def = typedef[t]
	if not def then return t end
	if type(def) == "function" then
		local t = { id = 0, import = {} } def(t, 0) def = t
		for k in pairs(t.import) do var.import[k] = true end
	end
	if type(def) == "table" then return type(def.type_o) == "string" and def.type_o or def.type_o(var) end
	error("ERROR: unknown subtypename(" .. var .. ", " .. t .. ")")
end
local function subtypename_new(var, t)
	if not var then return jdk7 and "" or ", " end
	return jdk7 and "" or subtypename(var, t)
end
local function subtypeid(t)
	local def = typedef[t]
	if not def then def = typedef.bean end
	if type(def) == "function" then local t = { id = 0, import = {} } def(t, 0) return t.subtypeid end
	if type(def) == "table" then return def.subtypeid end
	error("ERROR: unknown subtypeid(" .. t .. ")")
end
local function get_unmarshal_kv(var, kv, t)
	local s = (typedef[var[kv]] or typedef.bean).unmarshal_kv
	return type(s) == "string" and s or s(var, kv, t)
end
typedef.byte =
{
	import = {},
	name_u = function(var) return var.name:sub(1, 1):upper() .. var.name:sub(2) end,
	type = "byte", type_i = "byte", type_o = "Byte",
	subtypeid = 0,
	public = "public ",
	final = "",
	new = "",
	init = "this.#(var.name) = #(var.name)",
	reset = "#(var.name) = 0",
	assign = "this.#(var.name) = b.#(var.name)",
	set = [[

	public void set#(var.name_u)(#(var.type) #(var.name))
	{
		this.#(var.name) = #(var.name);
	}
]],
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", var.id * 4) end,
	unmarshal = "case #(var.id): this.#(var.name) = (#(var.type))s.unmarshalInt(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "(" .. typename(var, var[kv]) .. ")s.unmarshalIntKV(" .. t .. ")" end end,
	hashcode = "this.#(var.name)",
	equals = "this.#(var.name) != b.#(var.name)",
	compareto = "this.#(var.name) - b.#(var.name)",
	tostring = "s.append(this.#(var.name)).append(',')",
	tojson = "s.append(\"\\\"#(var.name)\\\":\").append(this.#(var.name)).append(',')",
	tolua = "s.append(\"#(var.name)=\").append(this.#(var.name)).append(',')",
}
typedef.char  = merge(typedef.byte, { type = "char",  type_i = "char",  type_o = "Char"  })
typedef.short = merge(typedef.byte, { type = "short", type_i = "short", type_o = "Short" })
typedef.int = merge(typedef.byte,
{
	type = "int",
	type_i = "int",
	type_o = "Integer",
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalInt(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalIntKV(" .. t .. ")" end end,
})
typedef.long = merge(typedef.byte,
{
	type = "long",
	type_i = "long",
	type_o = "Long",
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalLong(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalLongKV(" .. t .. ")" end end,
	hashcode = "(int)this.#(var.name)",
	compareto = "Long.signum(this.#(var.name) - b.#(var.name))",
})
typedef.bool = merge(typedef.byte,
{
	type = "boolean", type_i = "boolean", type_o = "Boolean",
	reset = "#(var.name) = false",
	marshal = function(var) return string.format("if(this.#(var.name)) s.marshal1((byte)0x%02x).marshal1((byte)1);", var.id * 4) end,
	unmarshal = "case #(var.id): this.#(var.name) = (s.unmarshalInt(t) != 0);",
	unmarshal_kv = function(var, kv, t) if kv then return "(s.unmarshalIntKV(" .. t .. ") != 0)" end end,
	hashcode = "(this.#(var.name) ? 0xcafebabe : 0xdeadbeef)",
	compareto = "(this.#(var.name) == b.#(var.name) ? 0 : (this.#(var.name) ? 1 : -1))",
})
typedef.float = merge(typedef.byte,
{
	type = "float", type_i = "float", type_o = "Float",
	subtypeid = 4,
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal2(0x%04x).marshal(this.#(var.name));", var.id * 0x400 + 0x308) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalFloat(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalFloatKV(" .. t .. ")" end end,
	hashcode = "Float.floatToRawIntBits(this.#(var.name))",
	compareto = "Float.compare(this.#(var.name), b.#(var.name))",
})
typedef.double = merge(typedef.byte,
{
	type = "double", type_i = "double", type_o = "Double",
	subtypeid = 5,
	marshal = function(var) return string.format("if(this.#(var.name) != 0) s.marshal2(0x%04x).marshal(this.#(var.name));", var.id * 0x400 + 0x309) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalDouble(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalDoubleKV(" .. t .. ")" end end,
	hashcode = "(int)((Double.doubleToRawLongBits(this.#(var.name)) * 0x100000001L) >> 32)",
	compareto = "Double.compare(this.#(var.name), b.#(var.name))",
})
typedef.string = merge(typedef.byte,
{
	import = { "jane.io.Util" },
	type = "String", type_i = "String", type_o = "String",
	subtypeid = 1,
	public = "private",
	new = "\t\t#(var.name) = \"\";\n",
	init = "this.#(var.name) = (#(var.name) != null ? #(var.name) : \"\")",
	reset = "#(var.name) = \"\"",
	assign = "this.#(var.name) = (b.#(var.name) != null ? b.#(var.name) : \"\")",
	set = [[

	public void set#(var.name_u)(#(var.type) #(var.name))
	{
		this.#(var.name) = (#(var.name) != null ? #(var.name) : "");
	}
]],
	marshal = function(var) return string.format("if(!this.#(var.name).isEmpty()) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", var.id * 4 + 1) end,
	unmarshal = "case #(var.id): this.#(var.name) = s.unmarshalString(t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalStringKV(" .. t .. ")" end end,
	hashcode = "this.#(var.name).hashCode()",
	equals = "!this.#(var.name).equals(b.#(var.name))",
	compareto = "this.#(var.name).compareTo(b.#(var.name))",
	tojson = "Util.toJStr(s.append(\"\\\"#(var.name)\\\":\"), this.#(var.name)).append(',')",
	tolua = "Util.toJStr(s.append(\"#(var.name)=\"), this.#(var.name)).append(',')",
})
typedef.octets = merge(typedef.string,
{
	import = { "jane.io.Octets" },
	type = "Octets", type_i = "Octets", type_o = "Octets",
	public = "public ",
	final = "final ",
	new = "\t\t#(var.name) = new Octets(#(var.cap));\n",
	init = "this.#(var.name) = new Octets(#(var.cap)); if(#(var.name) != null) this.#(var.name).replace(#(var.name))",
	reset = "#(var.name).clear()",
	assign = "if(b.#(var.name) != null) this.#(var.name).replace(b.#(var.name)); else this.#(var.name).clear()",
	set = "",
	marshal = function(var) return string.format("if(!this.#(var.name).empty()) s.marshal1((byte)0x%02x).marshal(this.#(var.name));", var.id * 4 + 1) end,
	unmarshal = "case #(var.id): s.unmarshal(this.#(var.name), t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalOctetsKV(" .. t .. ")" end end,
	tojson = "this.#(var.name).dumpJStr(s.append(\"\\\"#(var.name)\\\":\")).append(',')",
	tolua = "this.#(var.name).dumpJStr(s.append(\"#(var.name)=\")).append(',')",
})
typedef.vector = merge(typedef.octets,
{
	import = { "java.util.ArrayList", "java.util.Collection", "jane.io.Util" },
	type = function(var) return "ArrayList<" .. subtypename(var, var.k) .. ">" end,
	type_i = function(var) return "Collection<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new ArrayList<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new ArrayList<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).addAll(b.#(var.name))",
	marshal = function(var) return string.format([[if(!this.#(var.name).isEmpty())
		{
			s.marshal2(0x%04x).marshalUInt(this.#(var.name).size());
			for(%s v : this.#(var.name))
				s.marshal(v);
		}]], var.id * 0x400 + 0x300 + subtypeid(var.k), subtypename(var, var.k)) end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t >> 3) != 0) { s.unmarshalSkipVarSub(t); break; }
				t &= 7;
				int n = s.unmarshalUInt();
				this.#(var.name).ensureCapacity(n < 0x10000 ? n : 0x10000);
				for(; n > 0; --n)
					this.#(var.name).add(%s);
			}]], get_unmarshal_kv(var, "k", "t")) end,
	compareto = "Util.compareTo(this.#(var.name), b.#(var.name))",
	tostring = "Util.append(s, this.#(var.name))",
	tojson = "Util.appendJson(s.append(\"\\\"#(var.name)\\\":\"), this.#(var.name))",
	tolua = "Util.appendLua(s.append(\"#(var.name)=\"), this.#(var.name))",
})
typedef.list = merge(typedef.vector,
{
	import = { "java.util.LinkedList", "java.util.Collection", "jane.io.Util" },
	type = function(var) return "LinkedList<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedList<" .. subtypename_new(var, var.k) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new LinkedList<" .. subtypename_new(var, var.k) .. ">(); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t >> 3) != 0) { s.unmarshalSkipVarSub(t); break; }
				t &= 7;
				for(int n = s.unmarshalUInt(); n > 0; --n)
					this.#(var.name).add(%s);
			}]], get_unmarshal_kv(var, "k", "t")) end,
})
typedef.deque = merge(typedef.list,
{
	import = { "java.util.ArrayDeque", "java.util.Collection", "jane.io.Util" },
	type = function(var) return "ArrayDeque<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new ArrayDeque<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new ArrayDeque<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.hashset = merge(typedef.list,
{
	import = { "java.util.HashSet", "java.util.Collection", "jane.io.Util" },
	type = function(var) return "HashSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new HashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new HashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.treeset = merge(typedef.list,
{
	import = { "java.util.TreeSet", "java.util.Collection", "jane.io.Util" },
	type = function(var) return "TreeSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new TreeSet<" .. subtypename_new(var, var.k) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new TreeSet<" .. subtypename_new(var, var.k) .. ">(); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.linkedhashset = merge(typedef.list,
{
	import = { "java.util.LinkedHashSet", "java.util.Collection", "jane.io.Util" },
	type = function(var) return "LinkedHashSet<" .. subtypename(var, var.k) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedHashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new LinkedHashSet<" .. subtypename_new(var, var.k) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).addAll(#(var.name))" end,
})
typedef.hashmap = merge(typedef.list,
{
	import = { "java.util.HashMap", "java.util.Map.Entry", "java.util.Map", "jane.io.Util" },
	type = function(var) return "HashMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new HashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new HashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	marshal = function(var) return string.format([[if(!this.#(var.name).isEmpty())
		{
			s.marshal2(0x%04x).marshalUInt(this.#(var.name).size());
			for(Entry<%s, %s> e : this.#(var.name).entrySet())
				s.marshal(e.getKey()).marshal(e.getValue());
		}]], var.id * 0x400 + 0x340 + subtypeid(var.k) * 8 + subtypeid(var.v), subtypename(var, var.k), subtypename(var, var.v)) end,
	unmarshal = function(var) return string.format([[case #(var.id):
			{
				this.#(var.name).clear();
				if(t != 3) { s.unmarshalSkipVar(t); break; }
				t = s.unmarshalByte();
				if((t >> 6) != 1) { s.unmarshalSkipVarSub(t); break; }
				int k = (t >> 3) & 7; t &= 7;
				for(int n = s.unmarshalUInt(); n > 0; --n)
					this.#(var.name).put(%s, %s);
			}]], get_unmarshal_kv(var, "k", "k"), get_unmarshal_kv(var, "v", "t")) end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.treemap = merge(typedef.hashmap,
{
	import = { "java.util.TreeMap", "java.util.Map", "jane.io.Util" },
	type = function(var) return "TreeMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new TreeMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">();\n" end,
	init = function(var) return "this.#(var.name) = new TreeMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.linkedhashmap = merge(typedef.hashmap,
{
	import = { "java.util.LinkedHashMap", "java.util.Map", "jane.io.Util" },
	type = function(var) return "LinkedHashMap<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	type_i = function(var) return "Map<" .. subtypename(var, var.k) .. ", " .. subtypename(var, var.v) .. ">" end,
	new = function(var) return "\t\t#(var.name) = new LinkedHashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap));\n" end,
	init = function(var) return "this.#(var.name) = new LinkedHashMap<" .. subtypename_new(var, var.k) .. subtypename_new() .. subtypename_new(var, var.v) .. ">(#(var.cap)); if(#(var.name) != null) this.#(var.name).putAll(#(var.name))" end,
	assign = "this.#(var.name).clear(); if(b.#(var.name) != null) this.#(var.name).putAll(b.#(var.name))",
})
typedef.bean = merge(typedef.octets,
{
	import = {},
	type = function(var) return var.type end,
	type_i = function(var) return var.type end,
	type_o = function(var) return var.type end,
	subtypeid = 2,
	new = function(var) return "\t\t#(var.name) = new " .. var.type .. "();\n" end,
	init = function(var) return "this.#(var.name) = (#(var.name) != null ? #(var.name).clone() : new " .. var.type .. "())" end,
	reset = "#(var.name).reset()",
	assign = "this.#(var.name).assign(b.#(var.name))",
	marshal = function(var) return string.format([[{
			int n = s.size();
			this.#(var.name).marshal(s.marshal1((byte)0x%02x));
			if(s.size() - n < 3) s.resize(n);
		}]], var.id * 4 + 2) end,
	unmarshal = "case #(var.id): s.unmarshalBean(this.#(var.name), t);",
	unmarshal_kv = function(var, kv, t) if kv then return "s.unmarshalBeanKV(new " .. typename(var, var[kv]) .. "(), " .. t .. ")" end end,
	compareto = "this.#(var.name).compareTo(b.#(var.name))",
	tojson = "this.#(var.name).toJson(s.append(\"\\\"#(var.name)\\\":\")).append(',')",
	tolua = "this.#(var.name).toLua(s.append(\"#(var.name)=\")).append(',')",
})
typedef.boolean = typedef.bool
typedef.integer = typedef.int
typedef.binary = typedef.octets
typedef.bytes = typedef.octets
typedef.data = typedef.octets
typedef.array = typedef.vector
typedef.arraydeque = typedef.deque
typedef.arraylist = typedef.vector
typedef.linkedlist = typedef.list
typedef.set = typedef.hashset
typedef.linkedset = typedef.linkedhashset
typedef.map = typedef.hashmap
typedef.linkedmap = typedef.linkedhashmap

local function trim(s)
	return s:gsub("[%c ]+", "")
end
local function do_var(var)
	if var.id and (var.id < 1 or var.id > 62) then error("ERROR: id=" .. var.id .. " must be in [1, 62]") end
	if not var.id then var.id = 0 end
	var.import = {}
	var.id2 = string.format("%2d", var.id)
	var.name = trim(var.name)
	var.type = trim(var.type)
	if var.comment and #var.comment > 0 then var.comment = " // " .. var.comment:gsub("%c", " ") else var.comment = ""  end
	if type(var.value) == "string" then var.value = "\"" .. var.value .. "\"" end
	var.value = var.value and " = " .. var.value or ""
	local basetype
	basetype, var.k, var.v, var.cap = var.type:match "^%s*([%w_]+)%s*<?%s*([%w_]*)%s*,?%s*([%w_]*)%s*>?%s*%(?%s*([%w%._]*)%s*%)?%s*$"
	if not var.cap then var.cap = "" end
	local def = typedef[basetype]
	if not def and basetype == var.type then def = typedef.bean end
	if type(def) == "table" then
		for k, v in pairs(def) do
			if type(v) == "function" then v = v(var) end
			var[k] = v
		end
	else
		error("ERROR: unknown type: " .. var.type .. " => " .. basetype)
	end
end
local function code_conv(code, prefix, t)
	return code:gsub("#%(" .. prefix .. "%.([%w_]+)%)", function(name) return t[name] end)
end
local function gen_uid(s)
	local h = 0
	for i = 1, #s do
		h = h % 0x10000000000 * 4093 + 1 + s:byte(i)
	end
	return string.format("0xbeac%04x%08xL", math.floor(h / 0x100000000) % 0x10000, h % 0x100000000)
end

local name_code = {}
local type_bean = {}
local name_bean = {}
local handlers = {}
local hdl_types = {}
local bean_order = {}
local tables = { imports = { ["java.util.HashMap"] = true, ["jane.io.Bean"] = true } }
function handler(hdls)
	handlers = hdls
	for _, v in ipairs(hdls) do
		handlers[v.name] = v
	end
end
local function bean_common(bean)
	bean.name = trim(bean.name)
	if bean.name:find("[^%w_]") or typedef[bean.name] or bean.name == "AllBeans" or bean.name == "AllTables" then error("ERROR: invalid bean.name: " .. bean.name) end
	if name_code[bean.name] then error("ERROR: duplicated bean.name: " .. bean.name) end
	if type_bean[bean.type] then error("ERROR: duplicated bean.type: " .. bean.type) end
	if bean.type < 1 or bean.type > 0x7fffffff then error("ERROR: invalid bean.type: " .. bean.type) end
	for name in (bean.handlers or ""):gmatch("([%w_]+)") do
		if not handlers[name] then error("ERROR: not defined handle: " .. name) end
		hdl_types[name] = hdl_types[name] or {}
		hdl_types[name][#hdl_types[name] + 1] = bean.type
	end
	type_bean[bean.type] = bean
	name_bean[bean.name] = bean
	bean.comment = bean.comment and #bean.comment > 0 and "\n/**\n * " .. bean.comment:gsub("\n", "<br>\n * ") .. "\n */" or ""
end
local function bean_const(code)
	return code:gsub("public  /%*", "private /*"):
		gsub("\tpublic void assign%(.-\n\t}\n\n", ""):
		gsub("\tpublic void set.-\n\t}\n\n", ""):
		gsub("\t@Override\n\tpublic void reset%(.-\n\t}", [[
	@Override
	public void reset()
	{
		throw new UnsupportedOperationException();
	}]]):
		gsub("\t@Override\n\tpublic OctetsStream unmarshal%(.-\n\t}", [[
	@Override
	public OctetsStream unmarshal(OctetsStream s) throws MarshalException
	{
		throw new UnsupportedOperationException();
	}]])
end
local function get_imports(import)
	local imports = {}
	for k in pairs(import) do
		imports[#imports + 1] = k
	end
	table.sort(imports, function(a, b) return a:gsub("^java%.", ".") < b:gsub("^java%.", ".") end)
	return concat(imports, ";\nimport ")
end
function bean(bean)
	bean_common(bean)

	bean.import = { ["jane.io.Bean"] = true, ["jane.io.MarshalException"] = true, ["jane.io.OctetsStream"] = true }
	local vartypes = { bean.name }
	for _, var in ipairs(bean) do
		do_var(var)
		if var.id > 0 then
			vartypes[#vartypes + 1] = var.type
			for _, v in ipairs(var.import) do
				bean.import[v] = true
			end
		end
	end
	if bean.poolsize and bean.poolsize > 0 then
		bean.import["jane.io.BeanPool"] = true
		bean.pool_def = "\n\tpublic  static final BeanPool<" .. bean.name .. "> BEAN_POOL = new BeanPool<" .. (jdk7 and "" or bean.name) .. ">(STUB, " .. bean.poolsize .. ");"
		bean.pool_func = [[

	@Override
	public ]] .. bean.name .. [[ alloc()
	{
		return BEAN_POOL.alloc();
	}

	@Override
	public void free()
	{
		BEAN_POOL.free(this);
	}
]]
	else
		bean.pool_def = ""
		bean.pool_func = ""
	end

	bean.imports = get_imports(bean.import)
	bean.uid = gen_uid(concat(vartypes))

	local code = template_bean:gsub("#{#(.-)#}#", function(body)
		local subcode = {}
		for _, var in ipairs(bean) do
			if var.id == 0 then subcode[#subcode + 1] = code_conv(body, "var", var) end
		end
		return concat(subcode)
	end):gsub("#%(#(.-)#%)#", function(body)
		local subcode = {}
		for _, var in ipairs(bean) do
			if var.id > 0 then subcode[#subcode + 1] = code_conv(code_conv(body, "var", var), "var", var) end
		end
		local code = concat(subcode)
		return code:sub(-2, -1) ~= ", " and code or code:sub(1, -3)
	end)

	bean.param_warning = (#vartypes > 1 and "" or "/** @param b unused */\n\t")
	name_code[bean.name] = code_conv(code, "bean", bean):gsub(#vartypes > 1 and "#[<>]#" or "#<#(.-)#>#", ""):gsub("\r", "")
	bean_order[#bean_order + 1] = bean.name
	if bean.const then name_code[bean.name] = bean_const(name_code[bean.name]) end
end
function rpc(bean)
	bean_common(bean)
	bean.uid = gen_uid(name_bean[bean.arg].uid .. name_bean[bean.res].uid)
	name_code[bean.name] = code_conv(template_rpcbean, "bean", bean):gsub("\r", "")
	bean_order[#bean_order + 1] = bean.name
end
local key_conv = { int = "Integer", integer = "Integer", Integer = "Integer", long = "Long", Long = "Long", float = "Float", Float = "Float", double = "Double", Double = "Double",
					string = "String", String = "String", binary = "Octets", bytes = "Octets", data = "Octets", octets = "Octets", Octets = "Octets" }
function dbt(table)
	local key_type = key_conv[table.key]
	if key_type then
		if key_type == "Octets" then tables.imports["jane.io.Octets"] = true end
		table.table = "Table"
		table.key = key_type
		if table.memory then table.keys = "null"
		elseif key_type == "String" then table.keys = "\"\""
		elseif key_type == "Octets" then table.keys = "Octets.EMPTY"
		else table.keys = key_type .. ".STUB" end
		table.keyg = table.keys:find("%.STUB$") and table.keys or "null"
		table.comma = ", "
		tables.imports["jane.io.Table"] = true
	elseif table.key == "id" then
		table.table = "TableLong"
		table.key = ""
		table.keys = ""
		table.keyg = "null"
		table.comma = ""
		tables.imports["jane.io.TableLong"] = true
	else
		table.table = "Table"
		table.keys = not table.memory and "#(table.key).STUB" or "null"
		table.keyg = table.keys
		table.comma = ", "
		tables.imports["jane.io.Table"] = true
	end
	table.values = table.memory and "null" or "#(table.value).STUB"
	if table.comment and #table.comment > 0 then table.comment = "/**\n\t * " .. table.comment:gsub("\n", "<br>\n\t * ") .. "\n\t */\n\t" end
	tables[#tables + 1] = table
end

dofile "allbeans.lua"

local function checksave(fn, d, change_count, pattern, typename)
	local f = open(fn, "rb")
	if f then
		local s = f:read "*a"
		f:close()
		if change_count > 0 then
			d = s:gsub("\n\t/%*\\.-\n\t\\%*/", d:gmatch("\n\t/%*\\.-\n\t\\%*/"), change_count):gsub(pattern, typename, 1)
		end
		if s == d then d = nil else print(" * " .. fn) end
	else
		print("+  " .. fn)
	end
	if d then
		f = open(fn, "wb")
		if not f then error("ERROR: can not create file: " .. fn) end
		f:write(d)
		f:close()
	end
end

local outpath = (arg[1] or "src"):gsub("\\", "/")
if outpath:sub(-1, -1) ~= "/" then outpath = outpath .. "/" end
for name, code in pairs(name_code) do
	checksave(outpath .. namespace .. "/bean/" .. name .. ".java", code, 0)
end

checksave(outpath .. namespace .. "/bean/AllBeans.java", (template_allbeans:gsub("#%[#(.-)#%]#", function(body)
	local subcode = {}
	for _, hdl in ipairs(handlers) do
		if hdl.path then
			local types = hdl_types[hdl.name] or {}
			hdl.count = #types
			subcode[#subcode + 1] = code_conv(body:gsub("#%(#(.-)#%)#", function(body)
				local subcode2 = {}
				for _, type in ipairs(types) do
					local bean = type_bean[type]
					subcode2[#subcode2 + 1] = code_conv(body, "bean", bean)
					if not bean.arg then
						checksave(outpath .. hdl.path:gsub("%.", "/") .. "/" .. bean.name .. "Handler.java", code_conv(code_conv(template_bean_handler:gsub("#%(#(.-)#%)#", function(body)
							local subcode3 = {}
							for _, var in ipairs(bean) do
								subcode3[#subcode3 + 1] = code_conv(body, "var", var)
							end
							return concat(subcode3)
						end), "hdl", hdl), "bean", bean):gsub("\r", ""), 1, "(%s+class%s+" .. bean.name .. "Handler%s+extends%s+BeanHandler%s*<)[%w_%s]+>", "%1" .. bean.name .. ">")
					else
						local bean_sub
						local bean_arg, bean_res = name_bean[bean.arg], name_bean[bean.res]
						checksave(outpath .. hdl.path:gsub("%.", "/") .. "/" .. bean.name .. "Handler.java", code_conv(code_conv(code_conv(code_conv(template_rpc_handler:gsub("#%(#(.-)#%)#", function(body)
							bean_sub = bean_sub and bean_res or bean_arg
							local subcode3 = {}
							for _, var in ipairs(bean_sub) do
								subcode3[#subcode3 + 1] = code_conv(body, "var", var)
							end
							return concat(subcode3)
						end), "hdl", hdl), "bean", bean), "bean_arg", bean_arg), "bean_res", bean_res):gsub(bean_arg ~= bean_res and "#[<>]#" or "#%<#(.-)#%>#", ""):
							gsub("\r", ""), 2, "(%s+class%s+" .. bean.name .. "Handler%s+extends%s+RpcHandler%s*<)[%w_%s]+,[%w_%s]+>", "%1" .. bean_arg.name .. ", " .. bean_res.name .. ">")
					end
				end
				return concat(subcode2)
			end), "hdl", hdl)
		end
	end
	return concat(subcode)
end):gsub("#%(#(.-)#%)#", function(body)
	local subcode = {}
	for _, beanname in ipairs(bean_order) do
		local bean = name_bean[beanname]
		subcode[#subcode + 1] = code_conv(body, "bean", bean)
	end
	return concat(subcode)
end)):gsub(#handlers > 0 and "#[<>]#" or "#%<#(.-)#%>#", ""):gsub("#%(bean.count%)", #bean_order):gsub("\r", ""), 0)

tables.count = #tables
tables.imports["jane.io.DBManager"] = true
tables.imports = get_imports(tables.imports)
checksave(outpath .. namespace .. "/bean/AllTables.java", (code_conv(template_alltables:gsub("#%(#(.-)#%)#", function(body)
	local subcode = {}
	local names = {}
	local ids = {}
	for _, table in ipairs(tables) do
		if names[table.name] then error("ERROR: duplicated table.name: " .. table.name) end
		if ids[table.id] then error("ERROR: duplicated table.id: " .. table.id) end
		if table.id < 1 or table.id > 0x7fffffff then error("ERROR: invalid table.id: " .. table.id) end
		names[table.name] = true
		ids[table.id] = true
		subcode[#subcode + 1] = code_conv(code_conv(body, "table", table), "table", table)
	end
	return concat(subcode)
end), "tables", tables):gsub(#tables > 0 and "#[<>]#" or "#<#(.-)#>#", ""):gsub("\r", "")), 0)

print "completed!"
